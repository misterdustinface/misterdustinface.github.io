<!doctype>
<html>
	<head>
		<style>
		#canvas{
			background: #000;
		}
		</style>
	</head>
	<body>
		
		<canvas id="canvas" width="640" height="360"></canvas>
		
	</body>
</html>

<script>

///////////////////////////////////////////////////////

window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;
window.onload = function(){
	window.addEventListener("keydown", keyDownEventHandler, false);
	window.addEventListener("keyup",   keyUpEventHandler, false);
};
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
ctx.font = "bold 16px Monospace";
var FPS = 30;
setInterval(gameLoop, 1000/FPS);

var WINNING_SCORE	= 10;
var LEFT_SCORE		= 0;
var RIGHT_SCORE		= 0;
var LEFT_WIN		= false;
var RIGHT_WIN		= false;
var MAX_PADDLE_SPEED	= 12;
var MAX_BALL_XVEL	= 20;
var PADDLE_OFFSET	= 20;
var BALL_SERVE_WITH_PADDLE_OFFSET = 20;
var SCORE_YPOS		= 20;
var MESSAGE_YPOS	= 250;

var COLORS = [	"#FFFFFF", 
		"#77C621", "#21C6A3", "#C621AC", "#C62721",
		"#00FF66", "#0066FF", "#FF0066", "#FF6600", 
		"#000000"];
var TEXTCOLOR = "#CCCCCC"; //"#777"

var LeftPaddle  = new PaddleObject(PADDLE_OFFSET);
var RightPaddle = new PaddleObject(canvas.width - PADDLE_OFFSET);
var PADDLES = [LeftPaddle, RightPaddle];

var Ball = new BallObject();
//var BALLS = [Ball];

//////////////////////////////////////////////////////////////////////////
function gameLoop(){
	update();
	draw();
}

function update(){
	updatePaddles();
	updateBalls();
	checkWin();
	if(shouldResetGame()) {
		resetGame();
	}
}

function draw(){
	clearCanvas();
	drawBall();
	for (var i = 0; i < PADDLES.length; i++)
		drawPaddle(PADDLES[i]);
	drawTextInfo();
}

function clearCanvas() {
	ctx.clearRect(0,0,canvas.width,canvas.height);
}

function drawBall() {
	ctx.beginPath();
	ctx.fillStyle = COLORS[ (Math.abs(Ball.colorindex) % COLORS.length) ];
	ctx.arc(Ball.x, Ball.y, Ball.radius, 0, 2*Math.PI, false);
	ctx.fill();
}

function drawPaddle(paddle) {
	ctx.beginPath();
	ctx.fillStyle = COLORS[ (Math.abs(paddle.colorindex) % COLORS.length) ];
	ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
	ctx.fill();
}

var SCOREFIELD_LENGTH = ctx.measureText("XX [Score] XX").width;
var PROMPT_BALL_SERVE_TEXT = "PRESS [SPACE]";
var PROMPT_BALL_SERVE_TEXT_LENGTH = ctx.measureText(PROMPT_BALL_SERVE_TEXT).width;
function drawTextInfo() {
	ctx.fillStyle = TEXTCOLOR;
	ctx.fillText(LEFT_SCORE + " [Score] " + RIGHT_SCORE, canvas.width/2 - (SCOREFIELD_LENGTH/2), SCORE_YPOS);

  	if(RIGHT_WIN || LEFT_WIN) {
  		var winnerText = (RIGHT_WIN ? "RIGHT WINS" : "LEFT WINS"); 
  		var length = ctx.measureText(winnerText).width;
		ctx.fillText(winnerText, canvas.width/2 - (length/2), MESSAGE_YPOS);
  	} else if (! Ball.isServed) {
    		ctx.fillText(PROMPT_BALL_SERVE_TEXT, canvas.width/2 - (PROMPT_BALL_SERVE_TEXT_LENGTH/2), MESSAGE_YPOS);
	}
}

function drawMouse() {
	ctx.fillStyle = COLORS[1];
	ctx.beginPath();
	ctx.arc(Mouse.x, Mouse.y, 2, 0, 2*Math.PI, false);
	ctx.fill();
}

///////////////////////////////////////////////////////////////////
var KEYS = {
	W: 87, A: 65, S: 83, D: 68,
	UP_ARROW: 38, LEFT_ARROW: 37, DOWN_ARROW: 40, RIGHT_ARROW: 39,
	SPACEBAR: 32, ESC: 27,
};

function keyDownEventHandler(e){
	if(e.keyCode == KEYS.SPACEBAR)
		serveBall();
	if(e.keyCode == KEYS.ESC)
		resetGame();
	
	if(e.keyCode == KEYS.W)
		LeftPaddle.up = true;
	if(e.keyCode == KEYS.S)
		LeftPaddle.down = true;
	if(e.keyCode == KEYS.UP_ARROW)
		RightPaddle.up = true;
	if(e.keyCode == KEYS.DOWN_ARROW)
		RightPaddle.down = true;
		
	if(e.keyCode == KEYS.D)
		LeftPaddle.colorindex++; 
	if(e.keyCode == KEYS.A)
		LeftPaddle.colorindex--;
	if(e.keyCode == KEYS.RIGHT_ARROW)
		RightPaddle.colorindex++;
	if(e.keyCode == KEYS.LEFT_ARROW)
		RightPaddle.colorindex--;
		
	//if(e.keyCode == KEYS.D) Ball.radius++;
	//if(e.keyCode == KEYS.A) Ball.radius--;
}

function keyUpEventHandler(e){

  	if(e.keyCode == KEYS.W)
		LeftPaddle.up = false;
	if(e.keyCode == KEYS.S)
		LeftPaddle.down = false;
	if(e.keyCode == KEYS.UP_ARROW)
		RightPaddle.up = false;
	if(e.keyCode == KEYS.DOWN_ARROW)
		RightPaddle.down = false;
}

// // MOUSE	
// var Mouse = {
// 	x: canvas.width/2,
// 	y: canvas.height/2,
// };
// canvas.onmousemove = function(event){	
// 	Mouse.x = event.clientX;
// 	Mouse.y = event.clientY;
// };
// canvas.onmousedown = function(){
// };
// canvas.onmouseup = function(){
// };

///////////////////////////////////////////////////////////////////
function PaddleObject(xPos) {
	this.width  = 4;
	this.height = 64;
	this.x = xPos;
	this.y = canvas.height/2 - this.height/2;
	this.yVel = 0;
	this.speed = 2;
	this.colorindex = 0;
	this.up    = false;
	this.down  = false;
	this.right = false;
	this.left  = false;
}

function BallObject() {
	this.radius = 4;
	this.x = canvas.width/2;
	this.y = canvas.height/2;
	this.xVel = 0;
	this.yVel = 0;
	this.speed = 10;
	this.colorindex = 0;
	this.isServed = false;
}

function intersects(circle, rectangle) {
	return 	circle.x + circle.radius >= rectangle.x
	&&	circle.x - circle.radius <= rectangle.x + rectangle.width
	&&	circle.y + circle.radius >= rectangle.y
	&&	circle.y - circle.radius <= rectangle.y + rectangle.height;
}

//function intersects(point, rectangle) {
//	return 	point.x >= rectangle.x && point.x <= rectangle.x + rectangle.width
//	&& 	point.y >= rectangle.y && point.y <= rectangle.y + rectangle.height;
//}

function updatePaddles(){
	for (var i = 0; i < PADDLES.length; i++) {
		applyControllerCommandToPaddle(PADDLES[i]);
		limitPaddleSpeed(PADDLES[i]);
		keepPaddleInBounds(PADDLES[i]);
    	}
}

function applyControllerCommandToPaddle(paddle) {
	if(paddle.up ^ paddle.down) {
 		if(paddle.up) 	paddle.yVel -= paddle.speed;
 		if(paddle.down)	paddle.yVel += paddle.speed;
 		paddle.y += paddle.yVel // move y position accordingly
	} else {
  		paddle.yVel *= 1/4.0;
  		paddle.y += paddle.yVel // move y position accordingly
  		//paddle.yVel = 0;
	}
}

function limitPaddleSpeed(paddle){
  	if(paddle.yVel > MAX_PADDLE_SPEED)
		paddle.yVel = MAX_PADDLE_SPEED;
	if(paddle.yVel < -MAX_PADDLE_SPEED)
		paddle.yVel = -MAX_PADDLE_SPEED;
}

function keepPaddleInBounds(paddle){
	if(paddle.y + paddle.height < 0)
		paddle.y = canvas.height;
	else if(paddle.y > canvas.height)
		paddle.y = -paddle.height;
}

function serveBall(){
	if(! Ball.isServed){
		
		Ball.xVel = Math.random() * Ball.speed;
		
		if(shouldBallFollowLeftPaddle() ^ shouldBallFollowRightPaddle()){
			if(shouldBallFollowLeftPaddle()) {
				Ball.yVel = LeftPaddle.yVel;
			}
			if(shouldBallFollowRightPaddle()) {
				Ball.yVel = RightPaddle.yVel;
				Ball.xVel = -Ball.xVel;
			}
		} else {
			Ball.yVel = Math.random() * Ball.speed;
			if(Math.random() > 0.5)
				Ball.yVel = -Ball.yVel;
			if(Math.random() > 0.5)
				Ball.xVel = -Ball.xVel;
		}
		
		Ball.isServed = true;
	}
}

function updateBalls(){
	if(! Ball.isServed) {
		haveBallFollowLosingPaddle();
	} else {
		Ball.x += Ball.xVel;
		Ball.y += Ball.yVel;
		swatBallIfTouchingPaddle();
		keepBallInBounds();
	}
}

function swatBallIfTouchingPaddle() {
	for(var i = 0; i < PADDLES.length; i++) {
		if(intersects(Ball, PADDLES[i])) {
			swatBall(PADDLES[i]);
		}
	}
}

function haveBallFollowLosingPaddle() {
	if (shouldBallFollowLeftPaddle()) {
		Ball.x = LeftPaddle.x + (LeftPaddle.width + BALL_SERVE_WITH_PADDLE_OFFSET) + Ball.radius;
		Ball.y = LeftPaddle.y + (LeftPaddle.height/2);
		keepBallInBounds();
	} else if (shouldBallFollowRightPaddle()) {
		Ball.x = RightPaddle.x - (BALL_SERVE_WITH_PADDLE_OFFSET) - Ball.radius;
		Ball.y = RightPaddle.y + (RightPaddle.height/2);
		keepBallInBounds();
	}
}

function shouldBallFollowLeftPaddle() {
	return RIGHT_SCORE > LEFT_SCORE && !RIGHT_WIN;
}
function shouldBallFollowRightPaddle() {
	return LEFT_SCORE > RIGHT_SCORE && !LEFT_WIN;
}

function swatBall(paddle){
	Ball.xVel = -Ball.xVel;
	if( Ball.xVel < 0 ) {
		Ball.xVel -= Math.random() * Ball.speed;
		if (Ball.xVel < -MAX_BALL_XVEL)
			Ball.xVel = -MAX_BALL_XVEL;
	}else{
		Ball.xVel += Math.random() * Ball.speed;
		if (Ball.xVel > MAX_BALL_XVEL)
			Ball.xVel = MAX_BALL_XVEL;
	}
		
	if( (paddle.yVel < 0 && Ball.yVel > 0) || (paddle.yVel > 0 && Ball.yVel < 0) )
		Ball.yVel = - Math.abs(Math.abs(paddle.yVel) - Math.abs(Ball.yVel));
	else if (Math.random() > 0.5)
		Ball.yVel = - Math.random() * Ball.speed;
}

function keepBallInBounds(){
	if(Ball.y + Ball.radius > canvas.height) {
		Ball.y = canvas.height - Ball.radius;
		Ball.yVel = -Ball.yVel;
	} else if(Ball.y - Ball.radius < 0) {
		Ball.y = Ball.radius;
		Ball.yVel = -Ball.yVel;
	}
	
	if(Ball.x - Ball.radius > canvas.width){
		LEFT_SCORE += 1;
		resetBall();
	} else if(Ball.x + Ball.radius < 0){
		RIGHT_SCORE += 1;
		resetBall();
	}
}

function checkWin(){
	if(RIGHT_SCORE >= WINNING_SCORE) RIGHT_WIN = true;
	if(LEFT_SCORE  >= WINNING_SCORE) LEFT_WIN  = true;
}

function resetBall(){
	delete Ball;
	Ball = new BallObject();
}

function shouldResetGame() {
	return (RIGHT_WIN || LEFT_WIN) && isPlayRequested();
}

function isPlayRequested() {
	return Ball.isServed;
}

function resetGame() {
	resetGameData();
	resetBall();
}

function resetGameData(){
	RIGHT_WIN = false;
	LEFT_WIN = false;
	RIGHT_SCORE = 0;
	LEFT_SCORE = 0;
}

</script>
